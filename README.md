# 前言

**实践出真知** -- 如果真想从 spring 中学到东西，你一定要动手写一个自己的 spring。

大家好，我是 mengzhishang，上面是我写完这两篇文章后的感悟，像很多人一样，我也断断续续看过一些 spring 的原理，大多是 Bean 的生命周期介绍，三层缓存解决循环依赖这些，坦白的说很难去记忆和理解。因为 spring 的设计具有极强的广度（领域划分）和深度（设计模式），**想从“管”中窥得 “spring” 这个豹真的很难**。

下定决心手撸这个 simple-spring 真的要感谢**小傅哥**，他的系列文章让一切变得简单和可能。如果只是对着 spring-framework 这个代码库去手写一个 spring 是极难的，因为你不知道要在哪里做非核心功能的取舍，也比较难去领悟 spring 颇多设计的巧妙。然而结合文档再去看源码，手写一个只有核心功能的版本，对大多数人来说是可接受的。

**取自开源，回报以开源**。整个 simple-spring 是在小傅哥的【[spring 手撸专栏](https://bugstack.cn/md/spring/develop-spring/2021-05-16-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Spring%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html)】基础上重新实现，框架设计几乎没有变化，和小傅哥原作的主要差异点：

*   对本人在学习和实践该专栏的过程中一些不解和设计上觉得有些跳跃的地方进行了个人见解的补充和层次设计；
*   每个大模块都进行了原创的**图形化**解释，帮助自己和读者更直观地理解；
*   代码对接口和方法提供了简化版的**全英文注释**，可以更好体会 spring-framework 设计者的最初想法；
*   **AOP 模块**和小傅哥的原文内容有较大差别；文章从 AOP Alliance 接口框架开始讲解，模块实现更接近 Spring；
*   代码仓库每个分支对应一个文章章节，更方便 spring 学习者们参考**对应分支学习**和实践；

**建议**：学习过程中理解某个类或者方法的功能时，最好根据名称去 spring-framework 中查看一遍注释和源码，而不是只看文中简单版的实现；

**仓库地址**：<https://github.com/shengdoupi/simple-spring/branches>

**整体结构**：本系列文章我们将分四个部分介绍，分别是两部分 spring 最核心的基础能力：**Bean 容器**和 **AOP**，以及 spring 在面向用户友好的演进中体感最明显的**注解化**能力，最后一部分我将介绍自己在公司做启动耗时优化专项时对 spring 做的**Bean 加载优化**工作。
![spring.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b57e711b675d43c58391fd69826a385b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924\&h=708\&s=46118\&e=png\&a=1\&b=ffffff)

开始前我们先通过 IoC 引入 Bean 容器。**IoC**（Inversion of Control）是控制反转。控制反转是种设计思想，在学习设计模式时我们知道：控制反转指的是框架代替用户控制程序，主要是利用了抽象的思想，系统层次之间不依赖具体而是依赖抽象。在使用时通过多态实现框架的灵活性；

Spring 中处处可见 IoC 思想（这也造就了其框架的定位），本节我们将从 spring 中对象创建的控制反转学习起。相比于程序通过new来主动创建对象，Spring将对象创建和管理的权利交给了**容器**，容器在程序运行时动态的创建对象和维护对象之间的关系。在实现时，这种和用户硬编码的解耦可以通过配置或者注解来实现。
# [Bean 容器实现](https://juejin.cn/spost/7374631918112014374)
## 01 实现一个最简单的Bean容器
Bean 容器的基本功能就是提供获取 Bean 的能力，这一章主要就 Spring 如何完整的获取一个 Bean 做学习和实践，主要包括了 Bean 的注册、创建（实例化、属性注入）和获取。其中，框架在控制反转的思想基础上，利用了大量设计模式去铺垫框架的可扩展能力，包括模版方法模式、策略模式；也按照功能职责做了细致的模块和层次划分，个人认为是高内聚低耦合的思想体现。
这一 part 的具体实现基本和小傅哥原文一致，因此介绍的比较简单直接。

![spring-01.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c991b9709204403a83b5733e635c7d88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1426&h=846&s=83378&e=png&a=1&b=ffffff)
## 02 配置化、自动化和扩展能力

第一章我们实现了 Bean 工厂最基本的功能：管理 Bean。但在单元测试时我们发现使用起来和真正的 Spring 体验差距有点太大：

*   注册一个 Bean 需要手写好多代码，都比我每次 new 对象都复杂，能否通过配置化实现呢？
*   从 Bean 的注册到获取使用者要多次和 BeanFactory 进行交互，需要使用者理解 Spring 的内部逻辑，能否通过自动化流程使得对使用者更黑盒一些？
*   正如开头讲的一样，在实现的过程中可以发现 Spring 的设计处处为扩展能力做了铺垫，包括多种设计模式的使用、模块的层次划分等；那么在 Spring 的设计目标中，究竟为 Bean 工厂做了哪些能力的扩展呢？

这一章我们就 Spring 中这三个问题的答案进行学习和实践。

![spring-02 (1).png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f59d0725e1b47f9919a2fd97ecce5fc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1743&h=1160&s=167931&e=png&a=1&b=ffffff)

